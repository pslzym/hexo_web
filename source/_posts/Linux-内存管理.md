---
title: Linux 内存管理
tags: |-

  - Linux操作运维
permalink: linux-nei-cun-guan-li
id: 41
updated: '2016-11-30 20:48:32'
date: 2016-11-30 20:43:11
---

## 内存管理

### 内存管理逻辑概念

*	逻辑地址：是在机器语言指令中,来说明操作数和指令的地址;每个逻辑地址包括两部分:段(Segment)和偏移量(Offset)。
* 线性地址：也通常成为虚拟地址,在32位系统中,它是32位的无符号整型,最大可以达到4G。
* 物理地址：就是真正物理内存上的地址。

 
![](/uploads/2016/11/1.png)
三种地址转换图

![](/uploads/2016/11/2.png)
分段和分页机制

![](/uploads/2016/11/3.png)
逻辑地址到线性地址图

线性地址到物理地址

```
	会把线性地址分为：10：10：12
	每一个线程的PageDirectory的初始地址都不同，保存在CR3寄存器里面。CR3所指定的就是就是PageDirectory的结构地址。
	PageDirectory占4k，一个页。每一项占4个字节。
	每一个PageTable表项也占4k，一个页。每一项占4个字节。
	
	以上两个数据结构每个进程是独立的。都分配在3G~4G的内核内存空间。
```

### 内存管理相关算法
* buddy : 解决空闲页的问题

```
在实际应用中，经常需要分配一组连续的页框，而频繁地申请和释放不同大小的连续页框，必然导致在已分配页框的内存块中分散了许多小块的 空闲页框。这样，即使这些页框是空闲的，其他需要分配连续页框的应用也很难得到满足。
为了避免出现这种情况，Linux内核中引入了伙伴系统算法(buddy system)。把所有的空闲页框分组为11个 块链表，每个块链表分别包含大小为1，2，4，8，16，32，64，128，256，512和1024个连续页框的页框块。最大可以申请1024个连 续页框，对应4MB大小的连续内存。每个页框块的第一个页框的物理地址是该块大小的整数倍。
```

* slab :	用于解决特定大小缓存浪费块空间的问题。

```
工作于物理内存页框分配器之上，管理特定大小对象的缓存，进行快速而高效的内存分配。
slab分配器为每种使用的内核对象建立单独的缓冲区。Linux 内核已经采用了伙伴系统管理物理内存页框，因此 slab分配器直接工作于伙伴系 统之上。每种缓冲区由多个 slab 组成，每个 slab就是一组连续的物理内存页框，被划分成了固定数目的对象。根据对象大小的不同，缺省情况下一个 slab 最多可以由 1024个页框构成。出于对齐 等其它方面的要求，slab 中分配给对象的内存可能大于用户要求的对象实际大小，这会造成一定的 内存浪费。
```

### 内存分配相关函数
*	__get_free_pages

```
　　unsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order)
　　__get_free_pages函数是最原始的内存分配方式，直接从伙伴系统中获取原始页框，返回值为第一个页框的起始地址
```

* kmem_cache_create/ kmem_cache_alloc是基于slab分配器的一种内存分配方式，适用于反复分配释放同一大小内存块的场合。首先用kmem_cache_create创建一个高速缓存区域，然后用kmem_cache_alloc从 该高速缓存区域中获取新的内存块。

*	kmalloc

```
　　void *kmalloc(size_t size, gfp_t flags)
　　kmalloc是内核中最常用的一种内存分配方式，它通过调用kmem_cache_alloc函 数来实现。kmalloc一次最多能申请的内存大小由include/linux/Kmalloc_size.h的 内容来决定.
```

* vmalloc

```
　　void *vmalloc(unsigned long size)
　　前面几种内存分配方式都是物理连续的，能保证较低的平均访问时间。但是在某些场合
中，对内存区的请求不是很频繁，较高的内存访问时间也 可以接受，这是就可以分配一段线性连续，物理不连续的地址，带来的好处是一次可以分配较大块的内存。vmalloc对 一次能分配的内存大小没有明确限制。出于性能考虑，应谨慎使用vmalloc函数。在测试过程中， 最大能一次分配1GB的空间。
```


